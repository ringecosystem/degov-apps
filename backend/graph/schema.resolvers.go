package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"

	"github.com/ringecosystem/degov-apps/graph/model"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	// Mock implementation for testing
	return &model.Todo{
		ID:   "1",
		Text: input.Text,
		Done: false,
		Priority: func() model.Priority {
			if input.Priority != nil {
				return *input.Priority
			} else {
				return model.PriorityMedium
			}
		}(),
		User: &model.User{
			ID:   input.UserID,
			Name: "Mock User",
		},
		CreatedAt: func() *string { s := "2023-01-01T00:00:00Z"; return &s }(),
	}, nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, input model.UpdateTodo) (*model.Todo, error) {
	// Mock implementation for testing
	return &model.Todo{
		ID: input.ID,
		Text: func() string {
			if input.Text != nil {
				return *input.Text
			} else {
				return "Updated Todo"
			}
		}(),
		Done: func() bool {
			if input.Done != nil {
				return *input.Done
			} else {
				return false
			}
		}(),
		Priority: func() model.Priority {
			if input.Priority != nil {
				return *input.Priority
			} else {
				return model.PriorityMedium
			}
		}(),
		User: &model.User{
			ID:   "user1",
			Name: "John Doe",
		},
		CreatedAt: func() *string { s := "2023-01-01T00:00:00Z"; return &s }(),
	}, nil
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string) (bool, error) {
	// Mock implementation for testing
	return true, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	// Mock implementation for testing
	return []*model.Todo{
		{
			ID:       "1",
			Text:     "Sample Todo 1",
			Done:     false,
			Priority: model.PriorityHigh,
			User: &model.User{
				ID:    "user1",
				Name:  "John Doe",
				Email: func() *string { s := "john@example.com"; return &s }(),
			},
			CreatedAt: func() *string { s := "2023-01-01T00:00:00Z"; return &s }(),
		},
		{
			ID:       "2",
			Text:     "Sample Todo 2",
			Done:     true,
			Priority: model.PriorityMedium,
			User: &model.User{
				ID:    "user2",
				Name:  "Jane Smith",
				Email: func() *string { s := "jane@example.com"; return &s }(),
			},
			CreatedAt: func() *string { s := "2023-01-02T00:00:00Z"; return &s }(),
		},
	}, nil
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id string) (*model.Todo, error) {
	// Mock implementation for testing
	return &model.Todo{
		ID:       id,
		Text:     "Sample Todo",
		Done:     false,
		Priority: model.PriorityMedium,
		User: &model.User{
			ID:    "user1",
			Name:  "John Doe",
			Email: func() *string { s := "john@example.com"; return &s }(),
		},
		CreatedAt: func() *string { s := "2023-01-01T00:00:00Z"; return &s }(),
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// Mock implementation for testing
	return []*model.User{
		{
			ID:    "user1",
			Name:  "John Doe",
			Email: func() *string { s := "john@example.com"; return &s }(),
		},
		{
			ID:    "user2",
			Name:  "Jane Smith",
			Email: func() *string { s := "jane@example.com"; return &s }(),
		},
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Mock implementation for testing
	return &model.User{
		ID:    id,
		Name:  "John Doe",
		Email: func() *string { s := "john@example.com"; return &s }(),
	}, nil
}

// TodoUpdated is the resolver for the todoUpdated field.
func (r *subscriptionResolver) TodoUpdated(ctx context.Context) (<-chan *model.Todo, error) {
	// Mock implementation for testing - in real app you'd use channels
	ch := make(chan *model.Todo, 1)
	go func() {
		defer close(ch)
		ch <- &model.Todo{
			ID:       "1",
			Text:     "Updated Todo",
			Done:     false,
			Priority: model.PriorityHigh,
			User: &model.User{
				ID:   "user1",
				Name: "John Doe",
			},
		}
	}()
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
